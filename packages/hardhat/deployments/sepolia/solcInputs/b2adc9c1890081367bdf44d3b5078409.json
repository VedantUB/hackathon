{
  "language": "Solidity",
  "sources": {
    "contracts/ProofOfImpact.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ProofOfImpact\r\n * @dev A smart contract that holds donations in escrow and releases funds to an NGO\r\n * based on verifiable proof of milestone completion by a designated Oracle.\r\n * Donors receive a conceptual \"Proof-of-Impact\" NFT (tracked by a simple counter).\r\n */\r\ncontract ProofOfImpact {\r\n\r\n    // --- STATE VARIABLES ---\r\n\r\n    address public owner;\r\n    uint256 public nextCampaignId = 1;\r\n    mapping(address => bool) public isOracle;\r\n\r\n    struct Milestone {\r\n        string description;\r\n        uint256 requiredAmount;\r\n        bool isProofSubmitted;\r\n        bool isVerified;\r\n        string proofUri;\r\n    }\r\n\r\n    struct Campaign {\r\n        address payable ngoAddress;\r\n        string title;\r\n        uint256 targetAmount;\r\n        uint256 amountRaised;\r\n        uint256 fundsReleased;\r\n        Milestone[] milestones;\r\n        uint256 nextMilestoneIndex;\r\n        bool completed;\r\n        uint256 impactNftCounter;\r\n    }\r\n\r\n    mapping(uint256 => Campaign) public campaigns;\r\n\r\n    // --- EVENTS ---\r\n\r\n    event CampaignCreated(uint256 campaignId, address indexed ngo, uint256 target);\r\n    event DonationReceived(uint256 campaignId, address indexed donor, uint256 amount);\r\n    event ProofSubmitted(uint256 campaignId, uint256 milestoneIndex, string proofUri);\r\n    event MilestoneVerifiedAndFundsReleased(uint256 campaignId, uint256 milestoneIndex, uint256 amountReleased);\r\n    event ImpactNftMinted(uint256 campaignId, address indexed donor, uint256 tokenId);\r\n\r\n    // --- MODIFIERS ---\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the platform owner can call this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracle() {\r\n        require(isOracle[msg.sender], \"Only a designated Oracle can call this function.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNGO(uint256 _campaignId) {\r\n        require(campaigns[_campaignId].ngoAddress == msg.sender, \"Only the campaign's NGO can call this function.\");\r\n        _;\r\n    }\r\n\r\n    // --- CONSTRUCTOR & RECEIVE FALLBACK ---\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        isOracle[msg.sender] = true;\r\n    }\r\n    \r\n    receive() external payable {\r\n        revert(\"Use the 'donate' function to contribute to a campaign.\");\r\n    }\r\n\r\n    // --- ORACLE MANAGEMENT ---\r\n\r\n    function setOracle(address _oracleAddress, bool _status) public onlyOwner {\r\n        isOracle[_oracleAddress] = _status;\r\n    }\r\n\r\n    // --- CAMPAIGN MANAGEMENT ---\r\n\r\n    function createCampaign(\r\n        address payable _ngoAddress,\r\n        string memory _title,\r\n        string[] memory _milestoneDescriptions,\r\n        uint256[] memory _milestoneAmounts\r\n    ) public onlyOwner returns (uint256) {\r\n        require(_milestoneDescriptions.length == _milestoneAmounts.length, \"Milestone arrays must be same length.\");\r\n        require(_milestoneDescriptions.length > 0, \"Campaign must have at least one milestone.\");\r\n\r\n        uint256 totalTarget = 0;\r\n        Milestone[] memory newMilestones = new Milestone[](_milestoneDescriptions.length);\r\n        \r\n        for (uint i = 0; i < _milestoneDescriptions.length; i++) {\r\n            require(_milestoneAmounts[i] > 0, \"Milestone amount must be greater than zero.\");\r\n            newMilestones[i] = Milestone({\r\n                description: _milestoneDescriptions[i],\r\n                requiredAmount: _milestoneAmounts[i],\r\n                isProofSubmitted: false,\r\n                isVerified: false,\r\n                proofUri: \"\"\r\n            });\r\n            totalTarget += _milestoneAmounts[i];\r\n        }\r\n\r\n        uint256 newCampaignId = nextCampaignId;\r\n        Campaign storage campaign = campaigns[newCampaignId];\r\n\r\n        campaign.ngoAddress = _ngoAddress;\r\n        campaign.title = _title;\r\n        campaign.targetAmount = totalTarget;\r\n        campaign.amountRaised = 0;\r\n        campaign.fundsReleased = 0;\r\n        campaign.nextMilestoneIndex = 0;\r\n        campaign.completed = false;\r\n        campaign.impactNftCounter = 0;\r\n\r\n        for (uint i = 0; i < newMilestones.length; i++) {\r\n            campaign.milestones.push(newMilestones[i]);\r\n        }\r\n\r\n        emit CampaignCreated(newCampaignId, _ngoAddress, totalTarget);\r\n        nextCampaignId++;\r\n        return newCampaignId;\r\n    }\r\n\r\n    // --- DONATION LOGIC ---\r\n\r\n    function donate(uint256 _campaignId) public payable {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        require(campaign.ngoAddress != address(0), \"Campaign does not exist.\");\r\n        require(msg.value > 0, \"Donation amount must be greater than zero.\");\r\n        require(!campaign.completed, \"Campaign is already completed.\");\r\n\r\n        campaign.amountRaised += msg.value;\r\n        campaign.impactNftCounter++;\r\n        \r\n        emit ImpactNftMinted(_campaignId, msg.sender, campaign.impactNftCounter);\r\n        emit DonationReceived(_campaignId, msg.sender, msg.value);\r\n    }\r\n\r\n    // --- PROOF & VERIFICATION LOGIC ---\r\n\r\n    function submitProof(uint256 _campaignId, string memory _proofUri) public onlyNGO(_campaignId) {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        uint256 index = campaign.nextMilestoneIndex;\r\n\r\n        require(!campaign.completed, \"Campaign is already completed.\");\r\n        require(index < campaign.milestones.length, \"No next milestone to submit proof for.\");\r\n        require(campaign.milestones[index].requiredAmount <= campaign.amountRaised - campaign.fundsReleased, \"Not enough funds in escrow for this milestone.\");\r\n        require(!campaign.milestones[index].isProofSubmitted, \"Proof for this milestone already submitted.\");\r\n\r\n        campaign.milestones[index].isProofSubmitted = true;\r\n        campaign.milestones[index].proofUri = _proofUri;\r\n\r\n        emit ProofSubmitted(_campaignId, index, _proofUri);\r\n    }\r\n\r\n    function verifyMilestoneAndRelease(uint256 _campaignId, uint256 _milestoneIndex) public onlyOracle {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        Milestone storage milestone = campaign.milestones[_milestoneIndex];\r\n\r\n        require(campaign.ngoAddress != address(0), \"Campaign does not exist.\");\r\n        require(!milestone.isVerified, \"Milestone is already verified.\");\r\n        require(milestone.isProofSubmitted, \"Proof must be submitted before verification.\");\r\n        require(_milestoneIndex == campaign.nextMilestoneIndex, \"Verification must be for the next sequential milestone.\");\r\n\r\n        milestone.isVerified = true;\r\n        uint256 amountToRelease = milestone.requiredAmount;\r\n        campaign.fundsReleased += amountToRelease;\r\n\r\n        (bool success, ) = campaign.ngoAddress.call{value: amountToRelease}(\"\");\r\n        require(success, \"Fund transfer failed to NGO.\");\r\n\r\n        campaign.nextMilestoneIndex++;\r\n\r\n        if (campaign.nextMilestoneIndex == campaign.milestones.length) {\r\n            campaign.completed = true;\r\n            uint256 remainingFunds = address(this).balance - (campaign.amountRaised - campaign.fundsReleased);\r\n            if (remainingFunds > 0) {\r\n                 (success, ) = campaign.ngoAddress.call{value: remainingFunds}(\"\");\r\n                 require(success, \"Remaining fund transfer failed.\");\r\n                 campaign.fundsReleased += remainingFunds;\r\n            }\r\n        }\r\n\r\n        emit MilestoneVerifiedAndFundsReleased(_campaignId, _milestoneIndex, amountToRelease);\r\n    }\r\n\r\n    function emergencyWithdraw(address payable _recipient, uint256 _amount) public onlyOwner {\r\n        require(_amount <= address(this).balance, \"Insufficient balance.\");\r\n        (bool success, ) = _recipient.call{value: _amount}(\"\");\r\n        require(success, \"Withdrawal failed.\");\r\n    }\r\n\r\n    // --- VIEW FUNCTIONS FOR FRONTEND ---\r\n\r\n    /**\r\n     * @dev Get campaign details (without milestones array which can't be returned directly)\r\n     */\r\n    function getCampaignInfo(uint256 _campaignId) public view returns (\r\n        address ngoAddress,\r\n        string memory title,\r\n        uint256 targetAmount,\r\n        uint256 amountRaised,\r\n        uint256 fundsReleased,\r\n        uint256 nextMilestoneIndex,\r\n        bool completed,\r\n        uint256 impactNftCounter,\r\n        uint256 milestoneCount\r\n    ) {\r\n        Campaign storage c = campaigns[_campaignId];\r\n        return (\r\n            c.ngoAddress,\r\n            c.title,\r\n            c.targetAmount,\r\n            c.amountRaised,\r\n            c.fundsReleased,\r\n            c.nextMilestoneIndex,\r\n            c.completed,\r\n            c.impactNftCounter,\r\n            c.milestones.length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get a specific milestone's details\r\n     */\r\n    function getMilestone(uint256 _campaignId, uint256 _milestoneIndex) public view returns (\r\n        string memory description,\r\n        uint256 requiredAmount,\r\n        bool isProofSubmitted,\r\n        bool isVerified,\r\n        string memory proofUri\r\n    ) {\r\n        require(_milestoneIndex < campaigns[_campaignId].milestones.length, \"Milestone index out of bounds.\");\r\n        Milestone storage m = campaigns[_campaignId].milestones[_milestoneIndex];\r\n        return (m.description, m.requiredAmount, m.isProofSubmitted, m.isVerified, m.proofUri);\r\n    }\r\n\r\n    /**\r\n     * @dev Get all milestones for a campaign\r\n     */\r\n    function getAllMilestones(uint256 _campaignId) public view returns (\r\n        string[] memory descriptions,\r\n        uint256[] memory requiredAmounts,\r\n        bool[] memory isProofSubmittedArray,\r\n        bool[] memory isVerifiedArray,\r\n        string[] memory proofUris\r\n    ) {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        uint256 length = campaign.milestones.length;\r\n        \r\n        descriptions = new string[](length);\r\n        requiredAmounts = new uint256[](length);\r\n        isProofSubmittedArray = new bool[](length);\r\n        isVerifiedArray = new bool[](length);\r\n        proofUris = new string[](length);\r\n        \r\n        for (uint256 i = 0; i < length; i++) {\r\n            Milestone storage m = campaign.milestones[i];\r\n            descriptions[i] = m.description;\r\n            requiredAmounts[i] = m.requiredAmount;\r\n            isProofSubmittedArray[i] = m.isProofSubmitted;\r\n            isVerifiedArray[i] = m.isVerified;\r\n            proofUris[i] = m.proofUri;\r\n        }\r\n        \r\n        return (descriptions, requiredAmounts, isProofSubmittedArray, isVerifiedArray, proofUris);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}